Node* Tree::Merge(Node* node) {
   Node* leftSib = GetLeftSibling(node);
   Node* rightSib = GetRightSibling(node);

   if (leftSib != nullptr && leftSib->numKeys >= 2)
      RotateRight(leftSib);
   else if (rightSib != nullptr && rightSib->numKeys >= 2)
      RotateLeft(rightSib);
   else {
      // Fuse
      if (leftSib == nullptr)
         node = Fuse(node, rightSib);
      else
         node = Fuse(leftSib, node);
   }

   return node;
}

string Tree::MinKey(Node* node) {
   Node* cur = node;

   while (cur->left != nullptr) {
      cur = cur->left;
   }

   return cur->keys[0];
}

Node* Tree::GetChild(Node* node, int childIndex) {
   if (childIndex == 0)
      return node->left;
   else if (childIndex == 1)
      return node->middle1;
   else if (childIndex == 2)
      return node->middle2;
   else if (childIndex == 3)
      return node->right;
   else
      return nullptr;
}

Node* Tree::BTreeNextNode(Node* node, string key) {
   if (key < node->keys[0])
      return node->left;
   else if (node->keys[1] == nullptr || key < node->keys[1])
      return node->middle1;
   else if (node->keys[2] == nullptr || key < node->keys[2])
      return node->middle2;
   else
      return node->right;
}

bool Tree::BTreeKeySwap(Node* node, string existing, string replacement) {
   if (node == nullptr)
      return false;

   int keyIndex = GetKeyIndex(node, existing);
   if (keyIndex == -1) {
      Node* next = NextNode(node, existing);
      return KeySwap(next, existing, replacement);
   }

   if (keyIndex == 0)
      node->keys[0] = replacement;
   else if (keyIndex == 1)
      node->keys[1] = replacement;
   else
      node->keys[2] = replacement;

   return true;
}